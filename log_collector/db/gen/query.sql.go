// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package db

import (
	"context"
	"time"
)

const getParsedLogByID = `-- name: GetParsedLogByID :one
SELECT id, timestamp, event_category, source_type, username, hostname, severity, raw_message FROM parsed_logs
WHERE id = $1
`

func (q *Queries) GetParsedLogByID(ctx context.Context, id int32) (ParsedLog, error) {
	row := q.db.QueryRowContext(ctx, getParsedLogByID, id)
	var i ParsedLog
	err := row.Scan(
		&i.ID,
		&i.Timestamp,
		&i.EventCategory,
		&i.SourceType,
		&i.Username,
		&i.Hostname,
		&i.Severity,
		&i.RawMessage,
	)
	return i, err
}

const insertParsedLog = `-- name: InsertParsedLog :one
INSERT INTO parsed_logs (
    timestamp,
    event_category,
    source_type,
    username,
    hostname,
    severity,
    raw_message
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, timestamp, event_category, source_type, username, hostname, severity, raw_message
`

type InsertParsedLogParams struct {
	Timestamp     time.Time
	EventCategory string
	SourceType    string
	Username      string
	Hostname      string
	Severity      string
	RawMessage    string
}

func (q *Queries) InsertParsedLog(ctx context.Context, arg InsertParsedLogParams) (ParsedLog, error) {
	row := q.db.QueryRowContext(ctx, insertParsedLog,
		arg.Timestamp,
		arg.EventCategory,
		arg.SourceType,
		arg.Username,
		arg.Hostname,
		arg.Severity,
		arg.RawMessage,
	)
	var i ParsedLog
	err := row.Scan(
		&i.ID,
		&i.Timestamp,
		&i.EventCategory,
		&i.SourceType,
		&i.Username,
		&i.Hostname,
		&i.Severity,
		&i.RawMessage,
	)
	return i, err
}

const listParsedLogs = `-- name: ListParsedLogs :many
SELECT id, timestamp, event_category, source_type, username, hostname, severity, raw_message FROM parsed_logs
ORDER BY timestamp DESC
LIMIT $1 OFFSET $2
`

type ListParsedLogsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListParsedLogs(ctx context.Context, arg ListParsedLogsParams) ([]ParsedLog, error) {
	rows, err := q.db.QueryContext(ctx, listParsedLogs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ParsedLog
	for rows.Next() {
		var i ParsedLog
		if err := rows.Scan(
			&i.ID,
			&i.Timestamp,
			&i.EventCategory,
			&i.SourceType,
			&i.Username,
			&i.Hostname,
			&i.Severity,
			&i.RawMessage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
